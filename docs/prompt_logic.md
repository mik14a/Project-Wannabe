# プロンプト生成ロジック解説 (Project Wannabe 内部仕様)

このドキュメントは、Project Wannabe アプリケーション内部で、ユーザーの操作とUIの状態に応じて、KoboldCpp APIに送信する最終的なプロンプト文字列がどのように組み立てられるかを解説します。

**参照コード:** `src/core/prompt_builder.py`

---

## Part 1: Current Prompt Logic (新仕様)

このセクションでは、現在の `dev` ブランチにおけるプロンプト生成ロジックを説明します。このロジックは、新モデルの学習データ形式と密接に関連しています。

### 1.1 基本的な流れ (Current)

1.  **UIデータ収集:** 現在のモード、本文、詳細情報タブの全データ（メタデータ、レーティング、オーサーズノート）を取得します。
2.  **タスク判定:** UIの状態に基づき、内部タスクタイプ (`GEN_INFO`, `GEN_ZERO`, `CONT_INFO`, `CONT_ZERO`, `IDEA_INFO`, `IDEA_ZERO`) を決定します。
3.  **Instruction 選択と整形:** タスクタイプに対応する基本Instructionを選択し、UIから取得したレーティング情報を付加します。
4.  **Input 生成:** タスクタイプに応じて、UIデータからInput文字列を生成します。
5.  **最終プロンプト整形:** 整形されたInstructionとInputを、Mistral Instruct形式のテンプレートに合わせて結合します。

### 1.2 タスク判定ロジック (Current)

`determine_task_and_instruction` 関数により、以下のロジックでタスクタイプが決定されます。

*   **メタデータ有無判定の厳密化:**
    *   `title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`, `dialogue_level` の各項目について、値が存在するか（空文字列や空リストでないか）を個別にチェックします。
    *   `generate`/`continue` モードでは、これらのいずれか一つでも存在すれば「メタデータあり」と判定されます。
    *   `idea` モードでは、`dialogue_level` を除いたメタデータのいずれか一つでも存在すれば「メタデータあり」と判定されます。
*   **タスクタイプ決定表:**

| 選択中のモード | 本文エリアの状態 | メタデータ有無 (上記判定) | 決定されるタスクタイプ |
| :------------- | :--------------- | :------------------------ | :--------------------- |
| `generate`     | 空               | あり                      | `GEN_INFO`             |
| `generate`     | 空               | なし                      | `GEN_ZERO`             |
| `generate`     | 入力あり         | あり                      | `CONT_INFO`            |
| `generate`     | 入力あり         | なし                      | `CONT_ZERO`            |
| `idea`         | (不問)           | あり (セリフ量除く)       | `IDEA_INFO`            |
| `idea`         | (不問)           | なし (セリフ量除く)       | `IDEA_ZERO`            |

### 1.3 Instructionテンプレートと整形 (Current)

1.  **基本テンプレート:** タスクタイプに応じて、以下の基本Instructionが選択されます。
    ```python
    # src/core/prompt_builder.py より
    INSTRUCTION_TEMPLATES = {
        "GEN_INFO": "以下の情報に基づいて小説本文を生成してください。",
        "GEN_ZERO": "自由に小説を生成してください。",
        "CONT_INFO": "参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。", # Updated
        "CONT_ZERO": "本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。", # Updated
        "IDEA_INFO": "以下の情報に基づいて、完全な小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
        "IDEA_ZERO": "自由に小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
    }
    ```
2.  **レーティング付加:** UIの詳細情報タブで選択されたレーティング (`general` または `r18`)、またはそれが未選択の場合は設定画面のデフォルトレーティングが使用され、基本Instructionの末尾に ` レーティング: {rating_to_use}` の形で追加されます。
    *   例: `自由に小説を生成してください。 レーティング: r18`

### 1.4 Input文字列の生成 (Current)

#### 1.4.1 メタデータフォーマット (`format_metadata` 関数)

*   UIから取得したメタデータ (`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`, `dialogue_level`) を、定義された日本語名の順序 (`INPUT_METADATA_ORDER_JA`) に基づいてフォーマットします。
    ```python
    # src/core/prompt_builder.py より
    INPUT_METADATA_ORDER_JA = [
        "タイトル", "キーワード", "ジャンル", "あらすじ", "設定", "プロット", "セリフ量"
    ]
    ```
*   各項目は `# {日本語名}:\n{値}` の形式で表現されます。
*   キーワードとジャンル (リスト形式) は、各要素が **なしで改行区切り** で結合されます (学習データ形式に準拠)。
    ```
    # キーワード:
    ファンタジー
    魔法
    ```
*   `idea` モードの場合、`dialogue_level` (セリフ量) はメタデータ文字列に含まれません。
*   各メタデータ項目間は、**2つの改行 (`\n\n`)** で区切られます。

#### 1.4.2 `GEN_` / `IDEA_` タスクのInput

*   上記 `format_metadata` 関数で生成されたメタデータ文字列が、そのまま `internal_input` となります。
*   メタデータが全くない場合 (`GEN_ZERO`, `IDEA_ZERO`) は、`internal_input` は空文字列 (`""`) になります。

#### 1.4.3 `CONT_` タスクのInput (重要: 複雑な形式)

継続タスク (`CONT_INFO`, `CONT_ZERO`) では、学習データ形式に合わせた特殊なInput構造が用いられます。

1.  **本文分割 (`split_main_text` 関数):**
    *   UIの本文エリアのテキスト (`main_text`) が、最後の約3行 (`tail`) と、それより前の部分 (`main_part`) に分割されます。
    *   行数が3行以下の場合は、`main_part` は空文字列、`tail` が全文となります。
2.  **ブロック生成:**
    *   `main_part` (空でない場合): `【本文】\n\`\`\`\n{main_part}\n\`\`\``
    *   メタデータ (存在する場合): `【参考情報】\n\`\`\`\n{metadata_input_string}\n\`\`\``
    *   オーサーズノート (空でない場合): `【オーサーズノート】\n\`\`\`\n{authors_note}\n\`\`\``
3.  **ブロック順序制御:**
    *   ユーザー設定 `cont_prompt_order` (`reference_first` または `text_first`) に基づき、「本文ブロック」と「参考情報ブロック」の順序が決まります。
    *   `reference_first` (デフォルト): 参考情報ブロック → 本文ブロック
    *   `text_first`: 本文ブロック → 参考情報ブロック
4.  **Input組み立て:**
    *   決定された順序で「本文ブロック」「参考情報ブロック」を配置します。
    *   その後に「オーサーズノートブロック」を追加します (存在する場合)。
    *   最後に、分割された本文の末尾 (`tail`) を **ブロックの外にそのまま** 追加します。
    *   各ブロック間、および最後の `tail` との間は、**単一の改行 (`\n`)** で区切られます。
5.  **`CONT_ZERO` の場合:** メタデータがないため、「参考情報ブロック」は生成されません。

**`CONT_INFO` (reference_first) のInput例:**

````
【参考情報】
```
# タイトル:
星降る夜の冒険
# キーワード:
ファンタジー
魔法
```
【本文】
```
古い地図を広げると、そこには見たこともない島が描かれていた。
インクが滲んで、一部は判読できない。
```
【オーサーズノート】
```
地図の謎を強調する。
登場人物の驚きを描写。
```
島の中心には奇妙な印がある。←これも本文
これは一体……？
````

参考情報→本文の大部分→オーサーズノート→本文の一部という形式です。Text_firstの場合、参考情報と、本文の大部分の挿入順が入れ替わります。

### 1.5 最終プロンプト整形 (Mistral形式 - Current)

選択・整形された `final_instruction` と生成された `internal_input` を、以下のように結合します。

```python
if internal_input:
    # Inputがある場合はInstructionとの間に改行1つ
    prompt = f"<s>[INST]{final_instruction}\n{internal_input}[/INST]"
else:
    # Inputがない場合はInstructionの直後に終了タグ
    prompt = f"<s>[INST]{final_instruction}[/INST]"
```

*   システムプロンプトは使用しません。
*   応答は `[/INST]` の後に続くことを期待します。

### 1.6 ストップシーケンス (Current)

*   ユーザーが設定画面で指定したストップシーケンスがAPIリクエストに渡されます。
*   デフォルト値は `src/core/settings.py` の `DEFAULT_SETTINGS["stop_sequences"]` で定義されています（具体的な値は `settings.py` を参照）。

### 1.7 IDEAタスク処理 (`IdeaProcessor` クラス)

IDEAタスク (`current_mode == "idea"`) における項目選択や「高速な手法」チェックボックスの状態に応じた具体的な処理は、`prompt_builder.py` で基本プロンプト (`<s>[INST]...[/INST]`) が生成された後、`src/core/idea_processor.py` 内の `IdeaProcessor` クラスによって実行されます。`IdeaProcessor` は主に以下の役割を担います。

1.  **初期化 (`__init__`)**:
    *   UIの詳細情報タブから現在の入力値 (`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`) を受け取り、内部に保持します。

2.  **高速モード前提条件チェック (`check_fast_mode_prerequisites`)**:
    *   ユーザーが「高速な手法」をチェックし、かつ特定の項目（例: `synopsis`）を選択した場合に呼び出されます。
    *   選択された項目よりも**前**にある項目（`IDEA_ITEM_ORDER` 配列に基づく順序: `title` -> `keywords` -> ... -> `plot`）がUIで入力されているかを確認します。
    *   もし先行する項目に入力漏れがある場合、`False` と警告メッセージを返します。（UI側でこの警告を表示し、ユーザーは続行を選択できますが、期待通りの結果にならない可能性があることを示唆します。）
    *   先行項目が全て入力されていれば `True` を返します。
    *   **注意:** UIロジックにより、「全体」生成時や最初の項目「タイトル」選択時には「高速な手法」チェックボックス自体が無効化されるため、この関数が呼ばれるのは実質的に2番目以降の項目選択時です。

3.  **Stop Sequence 決定 (`determine_stop_sequence`)**:
    *   ユーザーが特定の項目（「全体」以外）を選択した場合に呼び出されます。
    *   選択された項目の**次**に来る項目のヘッダー文字列（例: 選択項目が `synopsis` なら、次の `setting` のヘッダー `# 設定:`）を特定し、これをStop Sequenceとして返します。これにより、AIが選択された項目を生成し終え、次の項目のヘッダーを出力しようとした時点で生成を停止させます。
    *   「全体」が選択された場合や、最後の項目 (`plot`) が選択された場合は、特定のStop Sequenceは不要なため `None` を返します。

4.  **プロンプト接尾辞生成 (`generate_prompt_suffix`)**:
    *   「高速な手法」が選択され、前提条件が満たされている（または警告を無視して続行された）場合に呼び出されます。
    *   選択された項目よりも**前**にある項目について、UIから取得した入力値をAIの出力形式（`# 日本語名:\n値`、項目間は `\n\n` 区切り）にフォーマットし、結合した文字列を生成します。
    *   この生成された文字列（接尾辞）は、`prompt_builder.py` が生成した基本プロンプトの `[/INST]` タグの**直後**に追加されます。これにより、AIは先行する項目が既に出力されているかのように認識し、選択された項目のヘッダー (`# {選択項目名}:`) から生成を開始することが期待されます。
    *   例: `synopsis` を高速モードで生成する場合、`title`, `keywords`, `genres` の入力値がフォーマットされて `[/INST]` の後に追加され、AIはその続きとして `# あらすじ:` から生成を始めることを狙います。

5.  **出力フィルタリング (`filter_output`)**:
    *   **「高速な手法」を使用せず**、かつ特定の項目（「全体」以外）を選択した場合に呼び出されます。
    *   この場合、AIはStop Sequence（次の項目のヘッダー）で停止することが期待されますが、完全に停止しなかったり、余分な空白や改行が含まれたりする可能性があるため、念のためフィルタリング処理が行われます。
    *   このメソッドは、AIからの完全な出力文字列 (`full_output`) を受け取り、選択された項目のヘッダー (`# {選択項目名}:`) から、次の項目のヘッダーが現れる直前までを抽出します。
    *   抽出された、選択項目に対応する部分文字列のみを最終的な出力として返します。
    *   **この後処理フィルタリングが必要なため、「高速な手法」を使用しない項目指定生成ではストリーミング表示ができません。**

**処理フローのまとめ:**

*   **全体生成 (項目指定なし):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor` は基本的に関与せず（Stop Sequenceなし）。
    *   API呼び出し (ストリーミング有効)。
*   **項目指定生成 (高速モード OFF):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor.determine_stop_sequence` で次の項目のヘッダーをStop Sequenceに設定。
    *   API呼び出し (ストリーミング**無効**)。
    *   `IdeaProcessor.filter_output` でAIの全出力から該当項目部分を抽出（Stop Sequenceで止まらなかった場合の保険）。
*   **項目指定生成 (高速モード ON, ※前提条件OK):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor.determine_stop_sequence` で次の項目のヘッダーをStop Sequenceに設定。
    *   `IdeaProcessor.generate_prompt_suffix` で先行項目の文字列を生成。
    *   基本プロンプト (`...[/INST]`) + 接尾辞 + Stop Sequence を用いてAPI呼び出し (ストリーミング有効)。
    *   (フィルタリングは基本的に不要だが、AIがStop Sequenceを無視した場合などに備える可能性はある)

このように、`prompt_builder.py` が提供する一貫した基本プロンプトに対し、`IdeaProcessor` がユーザーの選択に応じてAPIリクエストの内容（Stop Sequence、接尾辞）やレスポンスの処理方法（フィルタリング、ストリーミング有効/無効）を動的に変更することで、IDEAタスクの多様な機能を実現しています。

---

## Part 2: Legacy Prompt Logic (旧仕様)

このセクションでは、過去のバージョン（`legacy` ブランチ相当）で用いられていたプロンプト生成ロジックを記録のために記述します。

### 2.1 基本的な流れ (Legacy)

1.  **タスク判定:** 現在のUI状態（モード、本文有無、詳細情報有無）に基づいてタスクタイプを決定。
2.  **Instruction 選択:** タスクタイプに対応する固定Instructionテンプレートを選択。
3.  **Input 生成:** UIから必要な情報を取得し、タスクタイプに応じた形式でInput文字列を生成。
4.  **最終プロンプト整形:** InstructionとInputをMistral形式テンプレートに合わせて結合。

### 2.2 タスク判定ロジック (Legacy)

以下の条件分岐により、内部タスクタイプが決定されていました。

| 選択中のモード | 本文エリアの状態 | 詳細情報タブの状態 | 決定されるタスクタイプ | 使用Instructionテンプレートキー |
| :------------- | :--------------- | :----------------- | :--------------------- | :---------------------------- |
| **小説生成**   | 空               | **入力あり**       | `GEN_INFO`             | `GEN_INFO`                    |
| **小説生成**   | 空               | 入力なし           | `GEN_ZERO`             | `GEN_ZERO`                    |
| **小説生成**   | **入力あり**     | **入力あり**       | `CONT_INFO`            | `CONT_INFO`                   |
| **小説生成**   | **入力あり**     | 入力なし           | `CONT_ZERO`            | `CONT_ZERO`                   |
| **アイデア出し** | (不問)           | **入力あり**       | `IDEA_INFO`            | `IDEA_INFO`                   |
| **アイデア出し** | (不問)           | 入力なし           | `IDEA_ZERO`            | `IDEA_ZERO`                   |

**補足 (Legacy):**

*   「詳細情報タブの状態」は、`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot` のいずれか1つ以上にユーザーが入力しているかどうかで判定されていました。`authors_note`, `rating`, `dialogue_level` は判定に含まれていませんでした。

### 2.3 固定Instructionテンプレート (Legacy)

以下のテンプレートが使用されていました。レーティング情報は含まれていません。

```python
# 旧バージョンの例
INSTRUCTION_TEMPLATES = {
    "GEN_INFO": "以下の情報に基づいて小説本文を生成してください。",
    "GEN_ZERO": "自由に小説を生成してください。",
    "CONT_INFO": "参考情報を基に以下の文章の続きを生成してください。",
    "CONT_ZERO": "以下の文章の続きを生成してください。",
    "IDEA_INFO": "以下の情報に基づいて、完全な小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
    "IDEA_ZERO": "自由に小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
}
```

### 2.4 Input文字列の生成 (Legacy)

*   **`GEN_INFO` / `GEN_ZERO` / `IDEA_INFO` / `IDEA_ZERO` タスクの場合:**
    1.  詳細情報タブから `title`, `keywords`, `genres`, `synopsis`, `setting`, `plot` を取得。
    2.  定義された順序に基づき `# {日本語名}:\n{値}` 形式で結合。
    3.  キーワードとジャンルは改行区切り。
    4.  項目間は改行2つで区切る。
    5.  入力がない場合は空文字列。
*   **`CONT_INFO` / `CONT_ZERO` タスクの場合:**
    1.  本文エリアのテキスト (`main_text`) を**そのまま全て**取得。
    2.  `CONT_INFO` の場合は、上記と同様にメタデータ文字列 (`metadata_input_string`) を生成。
    3.  最終的な `internal_input` を以下の形式で組み立てていました。**(Current 仕様と大きく異なる点)**
        ```
        【本文】
        ```
        {main_text 全体}
        ```
        {metadata_input_string が存在する場合のみ、以下を追加}
        【参考情報】
        ```
        {metadata_input_string}
        ```
        ```
    4.  `CONT_ZERO` の場合は `【参考情報】...` 部分は追加されません。
    5.  **注意:** 本文の分割、オーサーズノートの挿入、末尾テキストの分離は行われていませんでした。

### 2.5 最終プロンプト整形 (Mistral形式 - Legacy)

InstructionとInputを以下のように結合していました (Current 仕様と同じ形式)。

```python
if internal_input:
    prompt = f"<s>[INST] {instruction_text}\n\n{internal_input} [/INST]"
else:
    prompt = f"<s>[INST] {instruction_text} [/INST]"
```

### 2.6 ストップシーケンス (Legacy)

*   ユーザーが設定画面で指定したストップシーケンス (`stop_sequences` リスト) は、KoboldCpp APIリクエスト時の `stop_sequence` パラメータに渡されます。これにより、モデルが不要なテンプレート文字列を生成した場合などに、そこで生成が停止されます。


---
